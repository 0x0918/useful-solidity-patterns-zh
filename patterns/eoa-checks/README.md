# 个人钱包地址（非合约地址）类型检查
- [📜 示例代码](./KingOfTheHill.sol)
- [🐞 测试](../../test/KingOfTheHill.t.sol)

个人钱包地址指的是那些从某私钥经过加密算法产生而来的地址。这些地址不是智能合约，也永远不会成为智能合约地址。说简单点，这些就是最普遍意义上的钱包地址，比如小狐狸钱包地址，冷钱包地址，还有纸钱包地址等等。另一种不同概念的钱包比如Argent和Gnosis Safe是“智能”钱包，他们实际上是定义了像钱包一样的功能的智能合约代码。

开发人员经常需要考虑到正在与之交互的地址是个人地址还是合约地址。了解它们之间的区别与后果是很重要的，尤其是你想要写一个比较完善的对恶意行为有防御性的合约。让我们来快速过一遍这些区别和它们会对你的合约产生什么样的影响。

### 向XXX发起调用
任何试图对一个个人地址发起的函数调用都会成功，但是没有代码会被执行也没有数据被返回。如果这个尝试的函数逻辑本身就不带返回值，那么这种情况就容易跟“试图对真的合约进行函数调用并且真的执行了”有所混淆，因为两种行为都不带返回值。所以要明确被发去调用的地址到底是不是一个智能合约，这是很重要的。

### 被来自于XXX调用
真正的个人地址（由私钥衍生而来的）[目前](https://eips.ethereum.org/EIPS/eip-3074)只能在*每项交易*里发起一条直接的函数调用，然而智能合约发起函数调用时却不受此限。重入攻击，套利交易，预言机操纵，闪电贷攻击等等这些行为若是从一个智能合约的一项交易中发起，就比从个人地址而来的若干项组合交易的完成方式要更加简单可行有利可图。这也是为何那些发生过的重大攻击事件都是先行部署一个用来攻击的智能合约，然后这些攻击行为都在同一条交易中一次性发起。

### ETH转账
在EVM层面，纯粹的ETH转账（例如  `address(receiver).transfer(1 ether)`, `address(receiver).send(1 ether)`, or `address(receiver).call{value: 1 ether}("")`）都会认做一个不含有calldata的空函数调用。正如前面提到过的，任何向EOA发起的调用都会成功并且不执行什么代码。但是如果转账目标实际是一个智能合约，它就会去运行这个合约的字节码，合约方获得了执行代码的权利来做它们设计好要做的事情（在gas够用的前提下）。除了广为人知的用这个机会来做重入攻击，恶意的合约还可以单纯地让交易逆转，这样你的合约的这个函数执行就永远不会成功。

### 代币转账
有的代币标准允许一种转账处理程序，会以接收方名义来发起一个标准的函数调用（例如 `onERC721Received()`）来作为对接收到代币转账的反应（类似于ETH转账可以触发某些代码执行）。所以某些代币转账给智能合约也会具有像ETH转账那样的风险。

### 被锁死的资产
各类资产（ETH，ERC20，ERC721等等）如果在个人地址中，那么始终都是可使用可转移的，只要拥有相应地址的私钥即可。然而，智能合约不是由私钥来控制的。如果一个合约没有写好特定的函数来对某种它持有的资产进行操作，则有可能这个资产就永远被锁死在此合约中了。这也是 `ERC721` 和 `ERC1155` 等代币标准中设计了具有“安全”转账功能的动机之一，这些代币合约要求接收者合约相应地对转账行为做出即时的反应，如 `onERC721Received()`，来表明此合约有意支持接收此种代币。

现在应该很明确了与智能合约交互通常被认为风险更高，因为你可能无法事先预知对方的行为，很可能会触发一系列复杂的后续交互动作而你的协议没办法处理。但有时候如果你预期对方是一个合约而实际对方是一个个人地址，可能同样会产生一些糟糕的后果。出于对此等情况的考虑，一些合约会在己方代码里加入一些对交互对象的账户类型的限制性。但是应该如何准确分辨对方的账户类型呢？

## `ADDRESS.code.length` 检查
实际上想要查看对方的地址是否存有代码进而来判断其是否为智能合约有一个很简单的方式。Solidity使用 `ADDRESS.code.length`，它会返回此地址存有的代码的长度。如果这个返回值非零，那么它就是一个智能合约！

```solidity
 function _isContractAt(address a) view returns (bool) {
    return a.code.length != 0;
 }
 ```

有一点很重要，就是这个检查没法保证这个地址就一定是个人钱包地址，因为它只是检查*现在*这个地址是否存有代码。所以另有一种情况是，其并非个人钱包地址，而是一个此刻尚未被部署任何代码的合约地址（此类地址的产生是具有[单向特定性](../factory-proofs/)的）。一个合约甚至可以在同一个交易中，而且刚好排在你的这个检查完成后，方才执行部署在那个特定的地址上。还有一种可能是某合约可以 `selfdestruct()` 自毁其代码，然后又通过 `CREATE2` 在这同一地址上重建新的代码。所以，这个检查方式应当被视为一种确定性较弱的EOA检查，而且通常被用作一种非紧要的常规完整性检查，或者被用在仅仅需要确定对方在这函数调用的短暂时间窗口内不是一个智能合约就足够了的情况下。

 ## `tx.origin` 检查
 这是一个可靠且便宜的方式来保证一个地址*一定是某个*个人钱包地址。在solidity里， `tx.origin` 返回签署了这个交易的地址，它一定是一个个人地址。因此如果你想检查的地址与 `tx.origin` 值相等，那么可以确定其一定且永远是个人地址。你会经常在直接面向用户的函数设计中以modifier的形式见到这种检查，它被用来确保减少合约暴露在风险下的程度，因为合约只能被来自于个人地址的交易调用其函数。
 
 ```solidity
 modifier onlyEOA() {
    require(tx.origin == msg.sender, 'only EOA can call');
    _;
 }
 ```
 
 注意这个检查只能在如果某地址与 `tx.origin`相一致的情况下给出确定性结论。那些与 `tx.origin` 不一致的地址也有可能是个人地址。

 ## Transaction Proofs

 假设你的合约能够查阅某个历史区块，而这个区块包含了某个个人地址签署的一笔交易，那么就存在另一种确定的但有些晦涩且技术宅的方式来检查某地址是EOA并且它不必非得与 `tx.origin` 相一致。

 每个被验证过的以太主网区块都有唯一的辨识标志“区块哈希值”，它可以被近似理解成这个区块包含的所有[属性信息](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash)经过哈希计算而得到的值。在这里我们最感兴趣的区块属性值就是它的 `transactionsRoot`。这是一个[默克尔树的根值](../merkle-proofs/)，由在此区块内的所有交易的哈希值再经过计算而得来。因为只有个人地址才能签署/从源头发起一项交易，理论上你就可以证明某个地址是个人地址类型，只要你能够提供验证来证明 - 此地址签署的某交易是构成某可供验证的区块哈希值的一部分。
 
 这种方式的细节可能会导致越挖越深所以我们就不深入展开了。但如果你想去仔细研究，那么得知道这个方式只对在主网上最近的[256个区块](https://docs.soliditylang.org/en/v0.8.17/units-and-global-variables.html#block-and-transaction-properties)内包含的交易是立即可行验证的。如果更早的交易，也不是不能验证，但是需要额外的工作。


## 你真的需要检查个人地址吗?
这些检查经常被用作缓解重入攻击和组合攻击（比如套利，预言机操纵）风险的一种快捷方式，或者被用来对某些交互行为进行“减速”（比如不允许用智能合约来参与发起NFT铸币）。看你使用的是哪种检查和如何使用它，这种保护可能都不会是全方位的。切记个人地址也有能力去在同一个区块里做多个不同的交互行为（通过不同的交易），而[flashbot bundles](https://docs.flashbots.net/flashbots-auction/searchers/advanced/understanding-bundles)的引入使这一点更容易去做了。但话说回来，很多开发者还是选择采用这种检查策略，可以理解，因为这些检查成本很低并且确实经常能够减少风险暴露面，怎么说，片面的保护也比没有保护要强一些，尤其是对于一些本身就算是低风险的应用。

这个检查带来的一点显著不好就是，它降低了你的合约和其他合约的可组合性。有些其它合约又可能是善意地想与你的合约构建组合来完善化应用的。还有就是可能有相当一部分的用户平时是使用智能钱包的，那这些人也就都不能参与你的协议了。但反正也不是所有的合约都真的在意可组合性，然后也无所谓丢失那些使用智能钱包的用户就是。这就要看你对你的产品的用户群的定义和期望了。

再有一点要说，这种地址类型检查想要防范的大多数攻击种类都可以有另外的更好的防御方法（比如说重入守卫，时间锁，让用户调用取钱函数而非合约发起送钱函数的方式。。。等等），这些方法就不会去限制你的用户的地址类型。

## 示例
[示例](./KingOfTheHill.sol) 展示了3个合约，它们都是来实现一个“当国王”的链上游戏。成为国王要花ETH，允许你在合约里发布一条自定义消息。任何人都可以成为新国王，只要他出比老国王更多的ETH并且调用 `takeCrown()` 函数。新国王出的钱会转给上一个老国王，以此类推。

最简单版本的合约 `BrickableKingOfTheHill` 有漏洞会受到“拒绝配合”的攻击，如果老国王是一个智能合约并且被设计成只要收到ETH就逆转当前的函数执行，它就会引起想当新国王的 `takeCrown()` 调用永远失败（例如[测试](../../test/KingOfTheHill.t.sol#L48)）。结果就是那个邪恶的合约永世称王。而 `OnlyEOAKingOfTheHill` 版本的合约修复了这一漏洞，它给 `takeCrown()` 函数加上了 `onlyEOA` 修饰。这就保证了每一个国王都是并且永远将是个人地址类型，则无法在收到ETH转账时触发逆转交易。 `ClaimableKingOfTheHill` 版本的合约也修复了这个漏洞，使用的方式是检查现在的老国王地址是否存有代码，若没有，则发送ETH；若有，则整理出这些ETH让老国王在另一项交易里自己去 `claim()` 收集它。
