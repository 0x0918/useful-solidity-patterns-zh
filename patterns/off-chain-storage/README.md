# 链下存储

- [📜 示例代码](./OffChainAuction.sol)
- [🐞 测试](../../test/OffChainAuction.t.sol)

存储操作往往占据大部分的智能合约执行成本。即使是那些需要在交互时跟踪多种状态量的简单协议，也需要对链上/合约存储进行多次写入和读取。按照EVM领域的一个经验法则，向空（零）槽写入非零值的成本为 20k，更新成本为 5k，读取成本在 100-2.1k 之间（感谢 [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929)），因此您可以看到这些成本是如何快速累积的。

围绕链上存储有许多减少 gas 消耗的策略，但不可否认的是，减少存储成本的单一最有效方法就是根本不在链上存储东西。😉

## 链下存储基础
链下存储的理念实际上是采用混合方。我们只在链上存储合约状态的*哈希值*。在链下跟踪完整状态，并在与合约交互时将其传递回来。因此，与通常的内联声明每个存储变量的方式不同，我们改为：

1. 在"状态对象" struct 中声明状态字段。
2. 将状态对象的哈希值存储在链上。
3. 要求用户在依赖状态的每次交互中传入完整的状态对象。
4. 验证传入的状态对象的哈希与我们存储的哈希是否匹配。
5. 对于需要读取这些存储字段的交互：
    1. 直接从 `calldata` 或 `memory` 读取数据，与从存储中读取相比，这种方式成本非常低廉。
6. 对于需要写入这些存储字段的交互：
    1. 根据需要,更新在（内存中的）状态对象中的字段。
    2. 计算新的状态对象哈希并更新链上哈希。
    3. 以事件的形式发出（和/或返回）更新后的状态对象，这样用户可以获取它并将其传递到下一个交互中。

采用这种方法，我们有可能在每次交互时将多次存储读写操作合并为只进行一次操作。

## 示例：NFT拍卖行

提供的[示例](./OffChainAuction.sol)是一个简单的 NFT（ERC721）拍卖行协议，利用了每个拍卖的链下状态。用户流程如下：

- 卖家调用 `createAuction()` 并传入拍卖参数（NFT、持续时间、最低出价等）。
    - 合约接管 NFT。
    - 选择一个新的 `auctionId`，并用提供的参数和状态在内存中创建一个关联的 `AuctionState` 对象，并用来跟踪拍卖进展。
    - 存储 `AuctionState` 的哈希，以 `auctionId` 为索引。
    - 发出完整的 `AuctionState` 对象。 
- 买家传入完整的 `AuctionState` 对象，调用 `bid()` 进行 ETH 竞标。 
- 任何人都可以调用 `settle()` 来完成拍卖（在拍卖过期或完成后），同样需要传入完整的 `AuctionState` 对象。
    - 在 `bid()` 和 `settle()` 中，会对 `AuctionState` 对象进行哈希并与该 `auctionId` 的对应的哈希值进行对比检查。 
    - 所有逻辑都只是对内存中的 `AuctionState` 对象进行读取和写入，这是成本较低的操作。
    - 在返回之前，用更新后的状态对象的哈希覆盖该 `auctionId` 对应的链上状态对象哈希。 
    - 发出包含完整更新的 `AuctionState` 对象的事件。

### 对比链上方案

拍卖行合约*每次拍卖*跟踪以下 8 个状态变量：


```solidity
IERC721 token;
uint256 tokenId;
address payable owner;
uint256 created;
uint256 started;
uint256 duration;
uint256 topBid;
address payable topBidder;
```
如果这些存储变量全部存储在链上，将它们一起初始化将花费 `8 * 20k = 160k` gas，并且之后每次更新将花费 `8 * 5k = 40k` gas。通过将它们合并为单个哈希，我们将这些成本降低了 8 倍（现在分别为 `20k` 和 `5k`）！


## 注意

虽然这种方法可能带来巨大的效率提升，但依赖链下数据也有一些值得注意的缺点和问题。


#### 基础设备负担

由于你的合约不再将完整的状态变量存储在存储器中，您的 dapp 将需要某些链下基础架构来获取合约交互的完整状态对象。幸运的是，因为我们发出包含完整对象的事件，在存档节点（例如，Alchemy）使用类似 `eth_getLogs` 的方法上获取最新状态对象相对来说是相当简单的。如果没有存档节点的访问权限，您可以启动一个服务来在事件发生时消费并缓存这些对象。


#### 可组合性

其他合约无法在纯链上环境中构建在您的协议之上。发起交易的外部账户将需要向合约提供有效的链下状态对象。根据您的协议在整个流程中所处的位置，这种模式可能并没有听起来那么破坏性，因为许多协议（尤其是在 DeFi 领域）已经依赖于链下组件以实现高效的使用（例如，Uniswap 池路由）。



#### 交易冲突 / 状态过期

如果需要相同状态对象的交互足够频繁，那么可能会出现两个挂起的交易尝试更新/与同一状态对象交互的情况，这会导致第二个交易失败，因为状态哈希将不再与存储的哈希值匹配。缓解这个现象的一种方法是将您的状态对象分成按照频繁一起修改进行分组，这样不相关的交互就不会影响彼此的状态。这也可以是有意为之，以损害其他用户。在拍卖示例中，当前最高出价者可以通过使用超出更高出价者 1 wei 增量的方式来保持其最高出价。改进的版本可能需要连续的出价有一个最小的百分比增量，以对这种行为产生抑制成本。


#### 状态对象约束

我们在每个需要状态对象的函数中对其进行哈希处理。这也带来一些成本，随着状态对象大小的增加而增加。出于这个原因，不建议在状态对象中存储大型数组，但是您可以隐式地使用 [merkle proofs](../merkle-proofs) 以在恒定空间内实现相同效果。此外，映射是仅限 `storage` 的结构，不容易在链下状态对象中编码，尽管您可以通过翻转数据结构来规避这一问题（例如，使用状态对象的映射而不是具有映射的状态对象）。
